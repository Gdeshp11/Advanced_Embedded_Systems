/*
 *  Description: LAB-8: Send nearest object distance value given by ultrasonic sensor from one MSP430G2553
 *  to another MSP430G2553 over UART,send various PWM signals(based on distance value) to speaker connected
 *  to first MSP430G2553 and display distance value on quad digit LED connected to second MSP430G2553
 *  file name: main.c
 *  Created on: Nov 16, 2022
 *  Author: Gandhar Deshpande, Owen Heckmann
 */

#include <msp430.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

// Input pin to check identify microcontroller (high if Tx and low if Rx)
#define MC_IDENTIFICATION_PIN BIT5 //p2.5

// Ultrasonic sensor pins
#define TRIGGER_PIN BIT5  //p1.5
#define ECHO_PIN BIT1 //p2.1

//PWM Output pin for speaker
#define PWM_OUT_SPEAKER BIT6 //p1.6

//UART PINS
#define TX_PIN BIT2 //p1.2
#define RX_PIN BIT1 //p1.1

// PORT2 pins for turning on LED digits
#define DIGIT_1 BIT3  //p2.3
#define DIGIT_2 BIT2  //p2.2
#define DIGIT_3 BIT1  //p2.1
#define DIGIT_4 BIT0  //p2.0

// 7 segments B-F of LED connected to pins of port1 and  A to port2
#define a BIT4    //p2.4
#define b BIT5    //p1.5
#define c BIT0    //p1.0
#define d BIT3    //p1.3
#define e BIT7    //p1.7
#define f BIT6    //p1.6
#define g BIT4    //p1.4

#define DIGDELAY 3000 // Number of cycles to delay for displaying each digit in display_digits
#define DELAY_SEC 1000000 //1 sec delay for 1MHz

typedef enum
{
    A_SEGMENT = 0,
    B_SEGMENT,
    C_SEGMENT,
    D_SEGMENT,
    E_SEGMENT,
    F_SEGMENT,
    G_SEGMENT,
} LED_SEGMENTS;

//******************************************************************************
// Module Function led_display_num(), Last Revision date 9/22/2022, by Gandhar
// Taking in a value, lights all of the segments required so that the value can be displayed
// Requires that the correct pins be declared on the top
//*******************************************************************************
void led_display_num(const unsigned val);

//******************************************************************************
// Module Function lit_let_segment(), Last Revision date 9/22/2022, by Gandhar
// Given a segment, turn it on.
//*******************************************************************************
void lit_led_segment(LED_SEGMENTS segment);

//******************************************************************************
// Module Function display_digits(), Last Revision date 9/22/2022, by Gandhar
// Given a number to display, turns on the digits in display that need to be turned on
// Then displays the digit, delaying an amount of time set in macros to improve persistence of vision
//*******************************************************************************
void display_digits(unsigned int val);

//******************************************************************************
//Module Function configureAdc(), Last Revision date 11/8/2022, by Gandhar
// function for initializing UART for pins 1.1 and 1.2
//*******************************************************************************
void uart_init();

//******************************************************************************
//Module Function serial_write(char *str,...)
//Last Revision date 11/19/2022, by Gandhar
// function for sending string of information to serial console.
// can accept formatted string as argument and then converts it to string.
//*******************************************************************************
void serial_write(const char *fmt, ...);

//******************************************************************************
//Module Function send_data(unsigned int adc_val),
//Last Revision date 11/8/2022, by Gandhar
// function for sending integer across UART
//*******************************************************************************
void send_data(const unsigned int distance);

//******************************************************************************
//interrupt serial_rx_interrupt, Last Revision date 11/8/2022, by Gandhar
//When a chip configured to listen to UART recieves data, extracts the
//Integer from the data stream, and writes it to the global variable adcValue
//*******************************************************************************
void serial_rx_interrupt(void);

//******************************************************************************
//interrupt timer_interrupt, Last Revision date 11/16/2022, by Gandhar
//interrupt generated by timer when echo pin receives PWM signal from ultrasonic sensor
//*******************************************************************************
void timer_interrupt(void);

void gpio_setup_tx(void);

void gpio_setup_rx(void);

void timer_setup(void);

void generate_trigger_signal();

void buzzer(const unsigned int cm);

void execute_tx();

void execute_rx();

volatile int rising_edge_value, falling_edge_value;
volatile int diff;
volatile unsigned int i = 0;
volatile int distance;
volatile unsigned char rxDataBytesCounter = 0;
volatile unsigned int distance_rx = 0;
volatile char rxBuf[25];

void main(void)
{
    WDTCTL = WDTPW | WDTHOLD;   // stop watchdog timer
    BCSCTL1 = CALBC1_1MHZ;
    DCOCTL = CALDCO_1MHZ;

    P2DIR &= ~MC_IDENTIFICATION_PIN; //set p2.5 as input

    //for UART Tx chip
    if (P2IN & MC_IDENTIFICATION_PIN)
    {
        //execute Tx code
        execute_tx();
    }
    //for UART Rx chip
    else if (!(P2IN & MC_IDENTIFICATION_PIN))
    {
        //execute Rx code
        execute_rx();
    }
}

void execute_tx()
{
    gpio_setup_tx();
    uart_init();
    timer_setup();
    __enable_interrupt();

    while (1)
    {
        generate_trigger_signal();
        __delay_cycles(DELAY_SEC / 3); //1/3 seconds delay
        // convert distance to cm
        distance = diff / 58;
        //play alarm on speaker
        buzzer(distance);
        serial_write("\r\n#distance:%d", distance);
    }
}

void execute_rx()
{
    // need to initialize uart before enabling uart interrupt otherwise interrupt doesn't work
    uart_init();
    gpio_setup_rx();
    __enable_interrupt();
    while (1)
    {
        display_digits(distance_rx);
    }
}

void gpio_setup_tx(void)
{

    //Timer P2SEL
    P1DIR = TRIGGER_PIN | PWM_OUT_SPEAKER;
    P2SEL = ECHO_PIN;
    //UART,PWM P1SEL
    P1SEL = TX_PIN | RX_PIN | PWM_OUT_SPEAKER;
    P1SEL2 = TX_PIN | RX_PIN;
    // Set TRIGGER (P1.6) pin to LOW initially
    P1OUT &= ~TRIGGER_PIN;
}

void gpio_setup_rx(void)
{
    P2DIR |= DIGIT_1 + DIGIT_2 + DIGIT_3 + DIGIT_4 + a;
    P1DIR |= b + c + d + e + f + g;
    P1SEL = TX_PIN | RX_PIN;
    P1SEL2 = TX_PIN | RX_PIN;
    P2SEL &= ~BIT6;  //enable p2.6 as gpio
    P2SEL &= ~BIT7;  //enable p2.7 as gpio
    P2OUT &= ~(DIGIT_1 + DIGIT_2 + DIGIT_3 + DIGIT_4); // all digits off by default
    UC0IE |= UCA0RXIE; // Enable USCI_A0 RX interrupt
}

void generate_trigger_signal()
{
    P1OUT |= TRIGGER_PIN;
    _delay_cycles(10);
    P1OUT &= ~TRIGGER_PIN;
//    _delay_cycles(60);
}

void timer_setup(void)
{
    //Timer configuration for generating PWM for speaker using pin p1.6 and timer T0.1
    TA0CTL = TASSEL_2 | MC_1;
    TA0CCR0 = 0;
    TA0CCR1 = 200;
    TA0CCTL1 = OUTMOD_7;

    //Timer configuration for echo pin (capture/compare) p2.1 using timer T1.1
    TA1CTL = TASSEL_2 | MC_2;
    TA1CCTL1 = CAP | CCIE | CCIS_0 | CM_3 | SCS;
}

#pragma vector = TIMER1_A1_VECTOR
__interrupt void timer_interrupt(void)
{
    // first interrupt when rising edge
    if (i == 0)
    {
        rising_edge_value = TA1CCR1;
        TA1CCTL1 &= ~CCIFG;
        i = 1;
    }
    // second interrupt when falling edge
    else if (i == 1)
    {
        falling_edge_value = TA1CCR1;
        TA1CCTL1 &= ~CCIFG;
        diff = falling_edge_value - rising_edge_value;
        i = 0;
    }
}

void uart_init()
{
    UCA0CTL1 |= UCSWRST + UCSSEL_2;
    UCA0BR0 = 104;  //settings for 9600 baud
    UCA0BR1 = 0;
    UCA0MCTL = UCBRS_0;
    UCA0CTL1 &= ~UCSWRST;
}

void serial_write(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    char msg[50];
    vsprintf(msg, fmt, args);
    int i = 0;

    while (msg[i] != 0)
    {
        while (!(IFG2 & UCA0TXIFG))
            ;
        UCA0TXBUF = msg[i];
        i++;
    }
}

#pragma vector = USCIAB0RX_VECTOR
__interrupt void serial_rx_interrupt(void)
{
    if (IFG2 & UCA0RXIFG)
    {
        __disable_interrupt();

        if (UCA0RXBUF == '\r' && rxDataBytesCounter == 0)
        {
            rxBuf[rxDataBytesCounter++] = UCA0RXBUF;
        }
        else if (rxDataBytesCounter > 0 && rxDataBytesCounter < 25)
        {
            rxBuf[rxDataBytesCounter++] = UCA0RXBUF;
        }
        else if (rxDataBytesCounter >= 25)
        {
            sscanf(rxBuf, "\r\n#distance:%d", &distance_rx);
            rxDataBytesCounter = 0;
        }

        IFG2 &= ~UCA0RXIFG;
        __enable_interrupt();
    }
}

void led_display_num(const unsigned val)
{
    // turn off all segments first
    P1OUT |= b + c + d + e + f + g;
    P2OUT |= a;
    // For each number, light the needed segments using program lit_let_segment
    switch (val)
    {
    case 0:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(B_SEGMENT);
        lit_led_segment(C_SEGMENT);
        lit_led_segment(D_SEGMENT);
        lit_led_segment(E_SEGMENT);
        lit_led_segment(F_SEGMENT);
        break;
    }
    case 1:
    {
        lit_led_segment(B_SEGMENT);
        lit_led_segment(C_SEGMENT);
        break;
    }
    case 2:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(B_SEGMENT);
        lit_led_segment(D_SEGMENT);
        lit_led_segment(E_SEGMENT);
        lit_led_segment(G_SEGMENT);
        break;
    }
    case 3:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(B_SEGMENT);
        lit_led_segment(C_SEGMENT);
        lit_led_segment(D_SEGMENT);
        lit_led_segment(G_SEGMENT);
        break;
    }
    case 4:
    {
        lit_led_segment(B_SEGMENT);
        lit_led_segment(C_SEGMENT);
        lit_led_segment(F_SEGMENT);
        lit_led_segment(G_SEGMENT);
        break;
    }
    case 5:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(C_SEGMENT);
        lit_led_segment(D_SEGMENT);
        lit_led_segment(F_SEGMENT);
        lit_led_segment(G_SEGMENT);
        break;
    }
    case 6:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(C_SEGMENT);
        lit_led_segment(D_SEGMENT);
        lit_led_segment(E_SEGMENT);
        lit_led_segment(F_SEGMENT);
        lit_led_segment(G_SEGMENT);
        break;
    }
    case 7:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(B_SEGMENT);
        lit_led_segment(C_SEGMENT);
        break;
    }

    case 8:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(B_SEGMENT);
        lit_led_segment(C_SEGMENT);
        lit_led_segment(D_SEGMENT);
        lit_led_segment(E_SEGMENT);
        lit_led_segment(F_SEGMENT);
        lit_led_segment(G_SEGMENT);
        break;
    }
    case 9:
    {
        lit_led_segment(A_SEGMENT);
        lit_led_segment(B_SEGMENT);
        lit_led_segment(C_SEGMENT);
        lit_led_segment(F_SEGMENT);
        lit_led_segment(G_SEGMENT);
        break;
    }
    default:
        lit_led_segment(G_SEGMENT);
        break;
    }
}

void lit_led_segment(LED_SEGMENTS segment)
{
    switch (segment)
    {
    case A_SEGMENT:
    {
        P2OUT &= ~a;
        break;
    }
    case B_SEGMENT:
    {
        P1OUT &= ~b;
        break;
    }
    case C_SEGMENT:
    {
        P1OUT &= ~c;
        break;
    }
    case D_SEGMENT:
    {
        P1OUT &= ~d;
        break;
    }
    case E_SEGMENT:
    {
        P1OUT &= ~e;
        break;
    }
    case F_SEGMENT:
    {
        P1OUT &= ~f;
        break;
    }
    case G_SEGMENT:
    {
        P1OUT &= ~g;
        break;
    }
    default:
        break;
    }
}

void display_digits(unsigned int val)
{
    unsigned int digit = 0;
    unsigned int number = val;

    if (val >= 0 && val <= 9)
    {
        // If the number is less than 10, turn on first digit and display the value
        digit = number % 10;
        P2OUT = DIGIT_4;
        led_display_num(digit);
    }
    else if (val >= 10 && val <= 99)
    {
        // If the number is more than 10, but less than 99
        // Turn on 1s place digit, display value, and delay
        // Then extract 10s place digit and repeat
        digit = number % 10;
        P2OUT = DIGIT_4;
        led_display_num(digit);
        digit = (number / 10) % 10;
        __delay_cycles(DIGDELAY);
        P2OUT = DIGIT_3;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
    }
    else if (val >= 100 && val <= 999)
    {
        // If the number is more than 10, but less than 99
        // Turn on 1s place digit, display value, and delay
        // Then extract 10s place digit and repeat
        // Then extract 1000s place digit and repeat again
        digit = number % 10;
        P2OUT = DIGIT_4;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
        digit = (number / 10) % 10;
        P2OUT = DIGIT_3;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
        digit = (number / 100) % 10;
        P2OUT = DIGIT_2;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
    }
    else if (val >= 1000 && val <= 9999)
    {
        // Do the same process as above, but for all 4 digits.
        digit = number % 10;
        P2OUT = DIGIT_4;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
        digit = (number / 10) % 10;
        P2OUT = DIGIT_3;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
        digit = (number / 100) % 10;
        P2OUT = DIGIT_2;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
        digit = (number / 1000) % 10;
        P2OUT = DIGIT_1;
        led_display_num(digit);
        __delay_cycles(DIGDELAY);
    }
}

//******************************************************************************
// Module Function void buzzer(unsigned int cm),
//Last Revision date 11/16/2022, by Owen
// Given a distance in cm, activates the buzzer with a certain pitch.
// Lower distances have higher pitches
//********************************************************************************
void buzzer(const unsigned int cm)
{
    if (cm <= 5)
    {
        TA0CCR0 = 300; //Set the period in the Timer A0 Capture/Compare 0 register to 2000 us (1/2000 us) is 500hz.
    }
    else if (cm < 10)
    {
        TA0CCR0 = 600; //Set the period in the Timer A0 Capture/Compare 0 register to 2000 us (1/2000 us) is 500hz.
    }
    else if (cm >= 10 && cm <= 15)
    {
        TA0CCR0 = 1250; //Set the period in the Timer A0 Capture/Compare 0 register to 2000 us (1/2000 us) is 500hz.
    }
    else if (cm > 15 && cm <= 20)
    {
        TA0CCR0 = 2500; //Set the period in the Timer A0 Capture/Compare 0 register to 2000 us (1/2000 us) is 500hz.
    }
    else if (cm > 20 && cm <= 25)
    {
        TA0CCR0 = 5000; //Set the period in the Timer A0 Capture/Compare 0 register to 2000 us (1/2000 us) is 500hz.
    }
    else if (cm > 25 && cm <= 30)
    {
        TA0CCR0 = 10000; //Set the period in the Timer A0 Capture/Compare 0 register to 2000 us (1/2000 us) is 500hz.
    }
    else
    {
        TA0CCR0 = 20000; //Set the period in the Timer A0 Capture/Compare 0 register to 2000 us (1/2000 us) is 500hz.
    }
}
